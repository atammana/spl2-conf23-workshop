{
  "modules": [
    {
      "name": "module1",
      "namespace": "",
      "definition": "//FIRST SCENARIO\nimport {main, billing} from ../../../../indexes;\n\n//SPL2 SYNTAX\n$target_data = from main | where sourcetype=\"aws:cloudtrail\" AND like(errorCode, \"%\")\n\n//Now, add a chained search!\n$cleanup_eventsource = from $target_data | rex field=eventSource mode=sed \"s/.amazonaws.com//g\"\n\n//Keep chaining, and add some post-processing filters.\n$user_eventSource_errors = from $cleanup_eventsource | stats count() as num_events by eventSource, userIdentity.userName | where num_events > 1000 | sort - num_events\n\n//Now write the same thing, but this time using SQL syntax in SPL2!\n$sql_version = SELECT count() AS num_events, eventSource, userIdentity.userName\nFROM main\nWHERE sourcetype=\"aws:cloudtrail\" AND errorCode!=null\nGROUP BY eventSource, userIdentity.userName\nHAVING num_events > 1000\nORDER BY num_events DESC\n| rex field=eventSource mode=sed \"s/.amazonaws.com//g\"\n\n//Use SPL2 with embedded SPL.\n$spl1_embedded = `| search index=main sourcetype=eventgen | iplocation sourceIPAddress | stats count by City`\n\nexport $sql_version as event_count_cleaned_source\n\n\n\n//SECOND SCENARIO\n\n\n//Write a test function to learn the basics of functions.\n/**\n * Cleans an AWS domain of extraneous information ending in \".amazonaws.com\".\n * \n * @param $field - the name of the field you want to clean.\n * \n * @example\n * This example shows how to use this custom eval function:\n * ```spl\n * $search_with_eval_function = from main | clean_aws_domain domain_field\n * ```\n */\nfunction clean_aws_domain($source, $field:object)\n{\n    return\n    | from $source | rex field=$field mode=sed \"s/.amazonaws.com//g\";\n}\n\n//Now, use the function in a test search. Hover over \"clean_aws_domain\" to see a tooltip pop up for your custom documentation!\n$search_using_function = from main | where sourcetype=\"aws:cloudtrail\" AND like(errorCode, \"%\") | clean_aws_domain eventSource;\n\n\n\n//Now, let's apply what we've learned to a more complex function.\n/**\n * An eval function that takes AWS CloudTrail request parameters as a JSON field of arbitrary depth and extracts the first-level keys & values. Returns a multivalue field that can be assigned in an eval function.\n * \n * @param $source - an implicit argument that pipes results into the function, making this a command function. An argument does not need to be specified here.\n * @param $request_parameters_json - The JSON field with the request parameters data. Type: object.\n * \n * @example\n * This example shows how to use this custom eval function:\n * ```spl\n * $search_extracting_request_parameters = from main sourcetype=aws:cloudtrail | eval request_parameters = extract_request_parameters(requestParameters)\n * ```\n */\nfunction extract_request_parameters($request_parameters_json: object): any[]\n{\n    $parameter_keys =  json_keys($request_parameters_json);\n    $key_value_pairs_json_array = map($parameter_keys, $it -> \"${$it}:${$request_parameters_json[$it]}\");\n\n    return json_array_to_mv($key_value_pairs_json_array);\n}\n/*\nLetâ€™s briefly walk through what this function just did.\n\n- This is a function called extract_request_parameters that takes an argument that is an object - a very vague type, but likely to be a JSON field - and returns an array of no type constraint within it.\n- In the function, we are using the json_keys function (you may recall this from SPL) to extract the keys from the JSON field argument, and return them as an array; this is assigned to $parameter_keys.\n- Next, we will use the flashy, revamped SPL2 map command to iterate through each value of the $parameter_keys array. We're also using a lambda expression to extract every key in the array (tokenized as $it), and the value of the key in each position of the array (specified by $request_parameters_json[$it]), with a colon in the middle, and assigning it to a new array. This will work with an array (and JSON object) of any size. Now we have an array of extracted key-value pairs!\n- The map() command in SPL2 works very differently than SPL. map in SPL iterates over events; it operates similarly to a subsearch. But the map() command in SPL2 iterates over a field, targeting more powerful field transformations! You can still achieve what the SPL map command does with subsearches.\n- To make the array more usable in the Splunk context with various mv commands, we use the json_array_to_mv() command on the extracted array and return the results.\n*/\n\n//Ok, now time to use this function in a search.\n$search_using_complex_function = from main | eval requestParameters = json_extract(_raw, \"requestParameters\") | WHERE isnotnull(requestParameters) | eval requestParameters_mv = extract_request_parameters(requestParameters); \n\nexport {main, extract_request_parameters};",
      "_vscode": {
        "metadata": {},
        "outputs": []
      }
    }
  ],
  "app": "apps.search"
}